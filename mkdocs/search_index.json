{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to the CbIL Documentation\n\n\n\n\n\n\n\nFor the increadibly confused, curious and bored folks!\n  \n\n\n\n\n\n\nIdiot Warning\n\n\nHello there. The author of this page may be an idiot, so please please \nplease\n if you find any grammatical errors or contexual/factual errors here, \nlet me know\n!\n\n\n\n\nWhat is this?\n\n\nCbIL stands for \nCommand block Intermediate Language\n. This program gives support for 2 languages:  \n\n\n\n\nlwlC:\n Lightweight Object Oriented language based on C#\n\n\nCbIL:\n  Command block Intermediate Language\n\n\n\n\nSupport for both languages exists due to the fact that an intermediate language is easier to parse and turn into a pattern of Minecraft commands.\nThis also provoides ease of access for porting into and out of existing languages such as the Redstone Programming Language (RPL).\nThe key concepts to note here are: Minecraft command blocks, and intermediate languages.\n\n\n\n\nNote\n\n\nAll hyperlinks are going to open in the same tab this page is in. You should probably (manually) open them in a new tab if you want to continue reading this article.\n\n\n\n\nCommand Blocks\n\n\nMinecraft is a childish game. Yes. But, that doesn't mean that it isn't particularly \ninteresting\n in its command features. Within the game, commands can\nbe typed in to induce certain effects on the environment, i.e., placing a block at a fixed location. However, most of these commands must be typed in manually\nas of Minecraft 1.7. In the 1.8 version of the game, \ncommand blocks\n were introduced that allowed the automation of these commands through a \nredstone signal\n.\n\nIf these concepts are not familiar, these articles might be of some help: \n1\n, \n2\n\nHowever, new improvements upon these command blocks have been made in the 1.9 version of the game. \nControl flow\n became an integral part of the command block system:\ncommand blocks can be activated based on the output of previous commands, the direction of the execution can be controlled allowing for more compact designs, and loops\nare now possible with the new additions. Even though these were possible in previous versions of Minecraft, the new improvements allows for control flow without actual\n\nredstone devices\n such as repeaters and comparators, which can often lead to lag and clunky designs.\n\n\nIntermediate Languages (IL)\n\n\n\n\nAsterisks! Exceptions! Over simplifications!\n\n\nOk, this portion of the article calls for lots of asterisk marks. So, please bear with me as I will not be placing any asterisk marks. Just know that they are implied.\n\n\n\n\nLet us suppose that you are a programmer - and you just completed your wonderful Paint program. Being the industrious fellow you are, you decide to port this program and\nmake it cross-platform. Then you realise a problem: you have to rewrite the program in (possibly) different languages using (possibly) different platform-specific libraries.\nHowever, being the good programmer that you are, you decided to stay away from dirty platform-specific hacks (supposed \"native\" calls), and the porting proccess is fairly easy.\n\nNow, imagine that there was this language that allows you to write the program once, and then it magically becomes corss-platform. There is such thing - it's called Java. Java\nis perhaps the most common - and well known - example of a language that gets compiled into an intermediate language: Java bytecode. Then, during runtime, the bytecode is parsed\non the spot and executed (insert asterisk here). This is called JIT compilation. Au contraire, CbIL is AOT, or Ahead-Of-Time where the code is compiled into the native machine\ncode before execution. So, to sum up, the core purpose of an IL is (usually) for optimization and portability. It acts like an in-between language for high-level languages and\nlow-level languages.  \n\n\n\n\nHigh level code \u2192 Compiler \u2192 Bytecode/IL \u2192 Machine Code (runtime or precompiled)  \n\n\n\n\nAlright, how does this all relate to CbIL? Well, as command blocks follow a completly different logic path than traditional programming languages, the IL is there to strip away any\nunnecessary human abstractions and leave behind only the control flow of the program (i.e., \nif\n statements, and \nwhile\n/\nfor\n loops). This makes the coding portion less messy for\nthe creator of the program and the user of the program. Abstraction can be increased, paradigm changed (linear \u2192 object oriented) and overall a cleaner output.  \n\n\nSome articles that may be useful: \n1\n \n2\n \n3\n  \n\n\nWord of Advice from the not-so Wise\n\n\nOk. So, many people would question whether I have gone insane and why I am wasting my time of such a \npointless\n project. Well, this project is not much \npointless\n as it is \npointful. It is my very first attempt at making any sort of parser, let alone a programming language (sort of). Yes, it is heavily based off of the C# syntax, but it does need\nto convert from one \nmindset\n to another. This project may not appeal to a widespread audience, nor do I hope that it will gain widespread popularity, but it is a learning\nexperience in it of itself for me, and for possibly you - the \nuser\n.\n\n\n\n\n\n\nEnd of Introduction",
            "title": "Introduction"
        },
        {
            "location": "/#welcome-to-the-cbil-documentation",
            "text": "For the increadibly confused, curious and bored folks!       Idiot Warning  Hello there. The author of this page may be an idiot, so please please  please  if you find any grammatical errors or contexual/factual errors here,  let me know !",
            "title": "Welcome to the CbIL Documentation"
        },
        {
            "location": "/#what-is-this",
            "text": "CbIL stands for  Command block Intermediate Language . This program gives support for 2 languages:     lwlC:  Lightweight Object Oriented language based on C#  CbIL:   Command block Intermediate Language   Support for both languages exists due to the fact that an intermediate language is easier to parse and turn into a pattern of Minecraft commands.\nThis also provoides ease of access for porting into and out of existing languages such as the Redstone Programming Language (RPL).\nThe key concepts to note here are: Minecraft command blocks, and intermediate languages.   Note  All hyperlinks are going to open in the same tab this page is in. You should probably (manually) open them in a new tab if you want to continue reading this article.",
            "title": "What is this?"
        },
        {
            "location": "/#command-blocks",
            "text": "Minecraft is a childish game. Yes. But, that doesn't mean that it isn't particularly  interesting  in its command features. Within the game, commands can\nbe typed in to induce certain effects on the environment, i.e., placing a block at a fixed location. However, most of these commands must be typed in manually\nas of Minecraft 1.7. In the 1.8 version of the game,  command blocks  were introduced that allowed the automation of these commands through a  redstone signal . \nIf these concepts are not familiar, these articles might be of some help:  1 ,  2 \nHowever, new improvements upon these command blocks have been made in the 1.9 version of the game.  Control flow  became an integral part of the command block system:\ncommand blocks can be activated based on the output of previous commands, the direction of the execution can be controlled allowing for more compact designs, and loops\nare now possible with the new additions. Even though these were possible in previous versions of Minecraft, the new improvements allows for control flow without actual redstone devices  such as repeaters and comparators, which can often lead to lag and clunky designs.",
            "title": "Command Blocks"
        },
        {
            "location": "/#intermediate-languages-il",
            "text": "Asterisks! Exceptions! Over simplifications!  Ok, this portion of the article calls for lots of asterisk marks. So, please bear with me as I will not be placing any asterisk marks. Just know that they are implied.   Let us suppose that you are a programmer - and you just completed your wonderful Paint program. Being the industrious fellow you are, you decide to port this program and\nmake it cross-platform. Then you realise a problem: you have to rewrite the program in (possibly) different languages using (possibly) different platform-specific libraries.\nHowever, being the good programmer that you are, you decided to stay away from dirty platform-specific hacks (supposed \"native\" calls), and the porting proccess is fairly easy. \nNow, imagine that there was this language that allows you to write the program once, and then it magically becomes corss-platform. There is such thing - it's called Java. Java\nis perhaps the most common - and well known - example of a language that gets compiled into an intermediate language: Java bytecode. Then, during runtime, the bytecode is parsed\non the spot and executed (insert asterisk here). This is called JIT compilation. Au contraire, CbIL is AOT, or Ahead-Of-Time where the code is compiled into the native machine\ncode before execution. So, to sum up, the core purpose of an IL is (usually) for optimization and portability. It acts like an in-between language for high-level languages and\nlow-level languages.     High level code \u2192 Compiler \u2192 Bytecode/IL \u2192 Machine Code (runtime or precompiled)     Alright, how does this all relate to CbIL? Well, as command blocks follow a completly different logic path than traditional programming languages, the IL is there to strip away any\nunnecessary human abstractions and leave behind only the control flow of the program (i.e.,  if  statements, and  while / for  loops). This makes the coding portion less messy for\nthe creator of the program and the user of the program. Abstraction can be increased, paradigm changed (linear \u2192 object oriented) and overall a cleaner output.    Some articles that may be useful:  1   2   3",
            "title": "Intermediate Languages (IL)"
        },
        {
            "location": "/#word-of-advice-from-the-not-so-wise",
            "text": "Ok. So, many people would question whether I have gone insane and why I am wasting my time of such a  pointless  project. Well, this project is not much  pointless  as it is \npointful. It is my very first attempt at making any sort of parser, let alone a programming language (sort of). Yes, it is heavily based off of the C# syntax, but it does need\nto convert from one  mindset  to another. This project may not appeal to a widespread audience, nor do I hope that it will gain widespread popularity, but it is a learning\nexperience in it of itself for me, and for possibly you - the  user .",
            "title": "Word of Advice from the not-so Wise"
        },
        {
            "location": "/#end-of-introduction",
            "text": "",
            "title": "End of Introduction"
        },
        {
            "location": "/lang/",
            "text": "Object Orientated Programming\n\n\nPreface\n\n\nProgramming languages can be classified by their \nparadigm\n. A \nprogramming paradigm\n is a way of programming. Some languages may be specialized in one paradigm while others\ncan be programmed in more than one. To learn more about paradigms, this article \nwill\n be helpful: \n1\n\nFor the sake of this article, we will only be focusing soely on one paradigm: object oriented, although the higher-level language (lwlC) can be considered imperataive too.\n\n\n\n\n\n\n\n\n\n\nSome complicated topics are not covered!\n\n\nFor the sake of this very simple \"lwlC\" language, \nsome\n advanced object oriented topics are not covered. If I missed something that you think should be covered, please \nlet me know!\n\n\n\n\nA Brief Definition of OOP\n\n\n\n\nObject-oriented programming (OOP) is a programming paradigm based on the concept of \"objects\", which may contain data, in the form of fields, often known as attributes;\nand code, in the form of procedures, often known as methods. A feature of objects is that an object's procedures can access and often modify the data fields of the object\nwith which they are associated (objects have a notion of \"this\" or \"self\").  \n\n\n\n\n\nObject-oriented programming. (2017, March 14). Retrieved March 15, 2017, from\n\n Wikipedia \n\n\n\n\nA Brief Overview of OOP Concepts\n\n\nObject\n\n\nThe basic (and most important) component in object oriented programming. It is both data and methods that modify the data in one entity. Objects are created by calling a\n\nconstructor\n. The constructor is defined in the class of the object. The creation of an object is called \ninstantiation\n and it creates an \ninstance\n of the object.\n\n\nClass\n\n\nClasses define what an object is going to be. It defines the fields and functions an object can have and perform. However, static classes\nare classes that can not be instantiated. As a result, a static class can not have a constructor method. They are a container for a set of method(s) that operate via\na set of input parameters. A static class \ncan only contain static members\n, which means all fields must be static. They cannot be inherited; so they are \nsealed\n.\n\n\nAbstraction\n\n\nI'm going to insert a quote here because it is going to explain it better than what I was about to say:\n\n\n\n\nAbstraction is \"the process of identifying common patterns that have systematic variations; an abstraction represents the common pattern and provides a means\nfor specifying which variation to use\" (Richard Gabriel).  \n\n\n\n\nLet's take some C# code from the Microsoft website:  \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\npublic\n \nabstract\n \nclass\n \nShape\n\n\n{\n\n    \nprivate\n \nstring\n \nname\n;\n\n\n    \npublic\n \nShape\n(\nstring\n \naName\n)\n \n//Constructor\n\n    \n{\n\n        \nID\n \n=\n \naName\n;\n\n    \n}\n\n\n    \n// This can be modified. Note the set keyword.\n\n    \npublic\n \nstring\n \nID\n \n{\n \nget\n \n{\n \nreturn\n \nname\n;\n \n}\n \nset\n \n{\n \nname\n \n=\n \nvalue\n \n}\n \n}\n\n\n    \n// Area is read-only. Note the absense of the set keyword.\n\n    \npublic\n \nabstract\n \ndouble\n \nArea\n \n{\n \nget\n;\n \n}\n\n\n    \n// Override the object.ToString() that comes with C#\n\n    \npublic\n \noverride\n \nstring\n \nToString\n()\n\n    \n{\n\n        \nreturn\n \nID\n \n+\n \n\" Area is \"\n \n+\n \nstring\n.\nFormat\n(\n\"{0:F2}\"\n,\n \nArea\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe above code identified the \ncommon attributes of shapes\n - the area and name. Now, we can create a variation of this shape by inheriting it:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\npublic\n \nclass\n \nSquare\n \n:\n \nShape\n \n// A square is a shape\n\n\n{\n\n    \n// The side attribute is unique to squares only. Since it was not needed,\n\n    \n// we did not put it in our abstract class. Instead, we put it in our\n\n    \n// (variation) child class. Ba-bam! Abstraction!\n\n    \nprivate\n \nint\n \nside\n;\n\n\n    \n// Let us override the default constructor to add a side parameter\n\n    \npublic\n \nSquare\n(\nint\n \naSide\n,\n \nstring\n \naID\n)\n\n        \n:\n \nbase\n \n(\naID\n)\n\n    \n{\n\n        \nthis\n.\nside\n \n=\n \naSide\n;\n\n    \n}\n\n\n    \n// Here, we return the area as side squared\n\n    \npublic\n \noverride\n \ndouble\n \nArea\n \n{\n \nget\n \n{\n \nreturn\n \nside\n \n*\n \nside\n;\n \n}\n \n}\n\n\n}\n\n\n\n\n\n\n\nSo, we can see that a square has a new property: side (length). As that property was unique to only the square (insert asterisk here), we did not add the property\nto our abstract class, because \nit was not needed\n. Instead, we added it to our child \nSquare\n class. To see more in depth into the example used: \n2\n\n\nEncapsulation\n\n\nOk, do not confuse this with \nabstraction\n. They are different concepts. Encapsulation is the means of hiding information that is not needed to the client of the object.\nWe encapsulate to reduce the complexity of the code. In some way, you can take an object someone has already made, use it in your code, and it should \njust work\n (insert asterisk).\nEncapsulation is achieved by using the accesor keywords: \npublic\n and \nprivate\n. The client of the object does not, and should not need to know \nhow\n and object is doing its work,\nand see the inner \"guts\" of the object. So, it is like a black box of some ways, where it \"just works\". Recommended article: \n3\n\nAlright. Some definitions \n \n4\n \n:\n\n\nMutater\n: This is a method that modifies the properties/state of an object. It can be a method, or through the \nset\n keyword.\n\n\nAccessor\n: This is something that gets the state of an object, usually through the \nget\n keyword.  \n\n\nInheritance\n\n\nInheritance is where you want the properties and methods of one object to be present in another. You may recall our abstract class \nShape\n example. In that example, the \nSquare\n\nclass inherits the \nShape\n class. Due to the \nShape\n class being abstract, the \nSquare\n class \nmust override\n all the methods and properties outlined in the \nShape\n class. With\nnormal class \u2192 class inheritance, overriding is not mandated. Let's say you have a class:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\npublic\n \nclass\n \nFoo\n\n\n{\n\n    \npublic\n \nvoid\n \nBar\n()\n\n    \n{\n\n        \nConsole\n.\nWriteLine\n(\n\"Hello from Foo!\"\n);\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nBar1\n()\n\n    \n{\n\n        \nConsole\n.\nWriteLine\n(\n\"Hello from Foo!\"\n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nFooBar\n \n:\n \nFoo\n\n\n{\n\n    \n// We are going to override the Bar1() method defined in Foo\n\n    \npublic\n \noverride\n \nvoid\n \nBar1\n()\n\n    \n{\n\n        \nConsole\n.\nWriteLine\n(\n\"BWAHAHAHA. I have overriden!\"\n);\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nDoStuff\n()\n\n    \n{\n\n        \nConsole\n.\nWriteLine\n(\n\"Hello from FooBar!\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nWe can see that \nFooBar\n inherits \nFoo\n. This means that you can call \nBar()\n from \nFooBar\n, but the output of \nBar1()\n from \nFooBar\n will be changed as it was overriden:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n// Create an instance of our two objects\n\n\nFoo\n \nobj\n \n=\n \nnew\n \nFoo\n();\n\n\nFooBar\n \nobj2\n \n=\n \nnew\n \nFooBar\n();\n\n\n\nobj\n.\nBar\n();\n\n\nobj\n.\nBar1\n();\n\n\n\nobj2\n.\nBar\n();\n \n//Inherited\n\n\nobj2\n.\nBar1\n();\n \n//Overriden\n\n\nobj2\n.\nDoStuff\n();\n \n//Added\n\n\n\n\n\n\n\nThis will output:\n\n\n1\n2\n3\n4\n5\nHello from Foo!\nHello from Foo!\nHello from Foo!\nBWAHAHAHA. I have overriden!\nHello from FooBar!\n\n\n\n\n\n\nHere is a nice article with a nice diagram to help you through: \n5\n\n\nPolymorphism\n\n\nIn the word polymorphism, poly is the Greek word for \"many\" or \"much,\" and \"morph\" means \"forms.\" Polymorphism is the ability for a method to proccess objects differently\nbased on their type or class. In other words, it is the ability to \noverride\n or \nredefine\n methods from parent classes.",
            "title": "The OOP Paradigm"
        },
        {
            "location": "/lang/#object-orientated-programming",
            "text": "",
            "title": "Object Orientated Programming"
        },
        {
            "location": "/lang/#preface",
            "text": "Programming languages can be classified by their  paradigm . A  programming paradigm  is a way of programming. Some languages may be specialized in one paradigm while others\ncan be programmed in more than one. To learn more about paradigms, this article  will  be helpful:  1 \nFor the sake of this article, we will only be focusing soely on one paradigm: object oriented, although the higher-level language (lwlC) can be considered imperataive too.      Some complicated topics are not covered!  For the sake of this very simple \"lwlC\" language,  some  advanced object oriented topics are not covered. If I missed something that you think should be covered, please  let me know!",
            "title": "Preface"
        },
        {
            "location": "/lang/#a-brief-definition-of-oop",
            "text": "Object-oriented programming (OOP) is a programming paradigm based on the concept of \"objects\", which may contain data, in the form of fields, often known as attributes;\nand code, in the form of procedures, often known as methods. A feature of objects is that an object's procedures can access and often modify the data fields of the object\nwith which they are associated (objects have a notion of \"this\" or \"self\").     \nObject-oriented programming. (2017, March 14). Retrieved March 15, 2017, from  Wikipedia",
            "title": "A Brief Definition of OOP"
        },
        {
            "location": "/lang/#a-brief-overview-of-oop-concepts",
            "text": "",
            "title": "A Brief Overview of OOP Concepts"
        },
        {
            "location": "/lang/#object",
            "text": "The basic (and most important) component in object oriented programming. It is both data and methods that modify the data in one entity. Objects are created by calling a constructor . The constructor is defined in the class of the object. The creation of an object is called  instantiation  and it creates an  instance  of the object.",
            "title": "Object"
        },
        {
            "location": "/lang/#class",
            "text": "Classes define what an object is going to be. It defines the fields and functions an object can have and perform. However, static classes\nare classes that can not be instantiated. As a result, a static class can not have a constructor method. They are a container for a set of method(s) that operate via\na set of input parameters. A static class  can only contain static members , which means all fields must be static. They cannot be inherited; so they are  sealed .",
            "title": "Class"
        },
        {
            "location": "/lang/#abstraction",
            "text": "I'm going to insert a quote here because it is going to explain it better than what I was about to say:   Abstraction is \"the process of identifying common patterns that have systematic variations; an abstraction represents the common pattern and provides a means\nfor specifying which variation to use\" (Richard Gabriel).     Let's take some C# code from the Microsoft website:     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 public   abstract   class   Shape  { \n     private   string   name ; \n\n     public   Shape ( string   aName )   //Constructor \n     { \n         ID   =   aName ; \n     } \n\n     // This can be modified. Note the set keyword. \n     public   string   ID   {   get   {   return   name ;   }   set   {   name   =   value   }   } \n\n     // Area is read-only. Note the absense of the set keyword. \n     public   abstract   double   Area   {   get ;   } \n\n     // Override the object.ToString() that comes with C# \n     public   override   string   ToString () \n     { \n         return   ID   +   \" Area is \"   +   string . Format ( \"{0:F2}\" ,   Area ); \n     }  }    The above code identified the  common attributes of shapes  - the area and name. Now, we can create a variation of this shape by inheriting it:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 public   class   Square   :   Shape   // A square is a shape  { \n     // The side attribute is unique to squares only. Since it was not needed, \n     // we did not put it in our abstract class. Instead, we put it in our \n     // (variation) child class. Ba-bam! Abstraction! \n     private   int   side ; \n\n     // Let us override the default constructor to add a side parameter \n     public   Square ( int   aSide ,   string   aID ) \n         :   base   ( aID ) \n     { \n         this . side   =   aSide ; \n     } \n\n     // Here, we return the area as side squared \n     public   override   double   Area   {   get   {   return   side   *   side ;   }   }  }    So, we can see that a square has a new property: side (length). As that property was unique to only the square (insert asterisk here), we did not add the property\nto our abstract class, because  it was not needed . Instead, we added it to our child  Square  class. To see more in depth into the example used:  2",
            "title": "Abstraction"
        },
        {
            "location": "/lang/#encapsulation",
            "text": "Ok, do not confuse this with  abstraction . They are different concepts. Encapsulation is the means of hiding information that is not needed to the client of the object.\nWe encapsulate to reduce the complexity of the code. In some way, you can take an object someone has already made, use it in your code, and it should  just work  (insert asterisk).\nEncapsulation is achieved by using the accesor keywords:  public  and  private . The client of the object does not, and should not need to know  how  and object is doing its work,\nand see the inner \"guts\" of the object. So, it is like a black box of some ways, where it \"just works\". Recommended article:  3 \nAlright. Some definitions    4   :  Mutater : This is a method that modifies the properties/state of an object. It can be a method, or through the  set  keyword.  Accessor : This is something that gets the state of an object, usually through the  get  keyword.",
            "title": "Encapsulation"
        },
        {
            "location": "/lang/#inheritance",
            "text": "Inheritance is where you want the properties and methods of one object to be present in another. You may recall our abstract class  Shape  example. In that example, the  Square \nclass inherits the  Shape  class. Due to the  Shape  class being abstract, the  Square  class  must override  all the methods and properties outlined in the  Shape  class. With\nnormal class \u2192 class inheritance, overriding is not mandated. Let's say you have a class:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 public   class   Foo  { \n     public   void   Bar () \n     { \n         Console . WriteLine ( \"Hello from Foo!\" ); \n     } \n\n     public   void   Bar1 () \n     { \n         Console . WriteLine ( \"Hello from Foo!\" ); \n     }  }  public   class   FooBar   :   Foo  { \n     // We are going to override the Bar1() method defined in Foo \n     public   override   void   Bar1 () \n     { \n         Console . WriteLine ( \"BWAHAHAHA. I have overriden!\" ); \n     } \n\n     public   void   DoStuff () \n     { \n         Console . WriteLine ( \"Hello from FooBar!\" ); \n     }  }   \nWe can see that  FooBar  inherits  Foo . This means that you can call  Bar()  from  FooBar , but the output of  Bar1()  from  FooBar  will be changed as it was overriden:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 // Create an instance of our two objects  Foo   obj   =   new   Foo ();  FooBar   obj2   =   new   FooBar ();  obj . Bar ();  obj . Bar1 ();  obj2 . Bar ();   //Inherited  obj2 . Bar1 ();   //Overriden  obj2 . DoStuff ();   //Added    This will output:  1\n2\n3\n4\n5 Hello from Foo!\nHello from Foo!\nHello from Foo!\nBWAHAHAHA. I have overriden!\nHello from FooBar!   Here is a nice article with a nice diagram to help you through:  5",
            "title": "Inheritance"
        },
        {
            "location": "/lang/#polymorphism",
            "text": "In the word polymorphism, poly is the Greek word for \"many\" or \"much,\" and \"morph\" means \"forms.\" Polymorphism is the ability for a method to proccess objects differently\nbased on their type or class. In other words, it is the ability to  override  or  redefine  methods from parent classes.",
            "title": "Polymorphism"
        },
        {
            "location": "/lwlC/",
            "text": "Lightwieght C# (lwlC)\n\n\n\n\n\nPreface\n\n\nThis is the human-readable component of the entire language framework. This object- oriented language is what the user types in to get parsed.\nThis article aims to give an overview as to how everything (kind of) works.  \n\n\nFeatures\n\n\n\n\n\n\n\n\nFeature\n\n\n\n\nProgress\n\n\n\n\n\n\n\n\n\n\nAn AI that does nothing\n\n\n\n\n\n\n\n\n\n\nDone\n\n\n\n\n\n\n\n\n\n\n\n\nStatic Classes\n\n\n\n\n\n\n\n\n\n\n20%\n\n\n\n\n\n\n\n\n\n\n\n\nClasses\n\n\n\n\n\n\n\n\n\n\n5%\n\n\n\n\n\n\n\n\n\n\n\n\nAbstract Classes\n\n\n\n\n\n\n\n\n\n\n0%\n\n\n\n\n\n\n\n\n\n\n\n\nInheritance\n\n\n\n\n\n\n\n\n\n\n0%\n\n\n\n\n\n\n\n\n\n\n\n\nEnumerators\n\n\n\n\n\n\n\n\n\n\n30%\n\n\n\n\n\n\n\n\n\n\n\n\nGeneric Types\n\n\n\n\n\n\n\n\n\n\n0%\n\n\n\n\n\n\n\n\n\n\n\n\nBasic control flow\n\n\n\n\n\n\n\n\n\n\n5%\n\n\n\n\n\n\n\n\n\n\n\n\n\"Multithreaded\" Execution\n\n\n\n\n\n\n\n\n\n\n0%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a0 \u00a0It has been implemented \n\n\n\n\u00a0 \u00a0It is in the proccess of being implemented \n\n\n\n\u00a0 \u00a0It is not being implemented and will not be for a while",
            "title": "Introduction to lwlC"
        },
        {
            "location": "/lwlC/#lightwieght-c-lwlc",
            "text": "",
            "title": "Lightwieght C# (lwlC)"
        },
        {
            "location": "/lwlC/#preface",
            "text": "This is the human-readable component of the entire language framework. This object- oriented language is what the user types in to get parsed.\nThis article aims to give an overview as to how everything (kind of) works.",
            "title": "Preface"
        },
        {
            "location": "/lwlC/#features",
            "text": "Feature   Progress      An AI that does nothing      Done       Static Classes      20%       Classes      5%       Abstract Classes      0%       Inheritance      0%       Enumerators      30%       Generic Types      0%       Basic control flow      5%       \"Multithreaded\" Execution      0%         \n\u00a0 \u00a0It has been implemented   \n\u00a0 \u00a0It is in the proccess of being implemented   \n\u00a0 \u00a0It is not being implemented and will not be for a while",
            "title": "Features"
        },
        {
            "location": "/CbIL/",
            "text": "Command Block Intermediate Language (CbIL)\n\n\n\n\n\nPreface\n\n\nDue to this being an intermediate language, CbIL is in bytecode. The bytecode consists of simple logic flow statements, and compiled commands. The compiled commands are stored\nin plaintext, and their contents will not change. Each operation is indicated by an one-byte code, followed by arguments. Variables are all integers, and they are referenced by\ntheir variable ID (numerically from 0 \u2192 \n\\({2}^{32}\\)\n ). The variable ID corresponds to a variable in a list located at the bottom of the code.\n\n\nFrom Object to Procedural\n\n\nObviously, we need to convert the object oriented lwlC into a procedural language. Conversion can be quite troublesome, and can lead to \nvery\n unoptimized code.\nFor example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\npublic\n \nclass\n \nBox\n\n\n{\n\n    \nint\n \nLength\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n    \nint\n \nWidth\n  \n{\n \nget\n;\n \nset\n;\n \n}\n\n    \nint\n \nDepth\n  \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n    \nint\n \nVolume\n\n    \n{\n\n        \nget\n\n        \n{\n\n            \nreturn\n \nLength\n \n*\n \nWidth\n \n*\n \nDepth\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\npublic\n \nstatic\n \nclass\n \nMain\n\n\n{\n\n    \nstatic\n \nvoid\n \nmain\n()\n\n    \n{\n\n        \nBox\n \nbox1\n \n=\n \nnew\n \nBox\n();\n\n        \nBox\n \nbox2\n \n=\n \nnew\n \nBox\n();\n\n        \nbox1\n.\nLength\n \n=\n \n10\n;\n\n        \nbox2\n.\nLength\n \n=\n \n20\n;\n\n        \nbox2\n.\nWidth\n \n=\n \n30\n;\n\n        \nbox2\n.\nDepth\n \n=\n \n40\n;\n\n        \nint\n \nvolume\n \n=\n \nbox2\n.\nVolume\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThis code should get converted to this:  \n\n\n\n\nNote\n\n\nLook at the number of variables as the optimization progresses.\n\n\n\n\n1\n2\n3\n4\n5\nint\n \nMain\n.\nmain\n.\nbox1\n.\nLength\n \n=\n \n10\n;\n\n\nint\n \nMain\n.\nmain\n.\nbox2\n.\nLength\n \n=\n \n20\n;\n\n\nint\n \nMain\n.\nmain\n.\nbox2\n.\nWidth\n \n=\n \n30\n;\n\n\nint\n \nMain\n.\nmain\n.\nbox2\n.\nDepth\n \n=\n \n40\n;\n\n\nint\n \nMain\n.\nmain\n.\nvolume\n \n=\n \nMain\n.\nmain\n.\nbox2\n.\nLength\n \n*\n \nMain\n.\nmain\n.\nbox2\n.\nDepth\n \n*\n \nMain\n.\nmain\n.\nbox2\n.\nWidth\n;\n\n\n\n\n\n\n\nAnd when data flow analysis happens:\n\n\n1\nint\n \nMain\n.\nmain\n.\nvolume\n \n=\n \n24000\n;",
            "title": "Introduction to CbIL"
        },
        {
            "location": "/CbIL/#command-block-intermediate-language-cbil",
            "text": "",
            "title": "Command Block Intermediate Language (CbIL)"
        },
        {
            "location": "/CbIL/#preface",
            "text": "Due to this being an intermediate language, CbIL is in bytecode. The bytecode consists of simple logic flow statements, and compiled commands. The compiled commands are stored\nin plaintext, and their contents will not change. Each operation is indicated by an one-byte code, followed by arguments. Variables are all integers, and they are referenced by\ntheir variable ID (numerically from 0 \u2192  \\({2}^{32}\\)  ). The variable ID corresponds to a variable in a list located at the bottom of the code.",
            "title": "Preface"
        },
        {
            "location": "/CbIL/#from-object-to-procedural",
            "text": "Obviously, we need to convert the object oriented lwlC into a procedural language. Conversion can be quite troublesome, and can lead to  very  unoptimized code.\nFor example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 public   class   Box  { \n     int   Length   {   get ;   set ;   } \n     int   Width    {   get ;   set ;   } \n     int   Depth    {   get ;   set ;   } \n\n     int   Volume \n     { \n         get \n         { \n             return   Length   *   Width   *   Depth ; \n         } \n     }  }  public   static   class   Main  { \n     static   void   main () \n     { \n         Box   box1   =   new   Box (); \n         Box   box2   =   new   Box (); \n         box1 . Length   =   10 ; \n         box2 . Length   =   20 ; \n         box2 . Width   =   30 ; \n         box2 . Depth   =   40 ; \n         int   volume   =   box2 . Volume ; \n     }  }    This code should get converted to this:     Note  Look at the number of variables as the optimization progresses.   1\n2\n3\n4\n5 int   Main . main . box1 . Length   =   10 ;  int   Main . main . box2 . Length   =   20 ;  int   Main . main . box2 . Width   =   30 ;  int   Main . main . box2 . Depth   =   40 ;  int   Main . main . volume   =   Main . main . box2 . Length   *   Main . main . box2 . Depth   *   Main . main . box2 . Width ;    And when data flow analysis happens:  1 int   Main . main . volume   =   24000 ;",
            "title": "From Object to Procedural"
        },
        {
            "location": "/compiler/",
            "text": "The Parser, Compiler and Stuff\n\n\nThese are the two key components to the whole process of lwlC \u2192 CbIL \u2192 Command Blocks. The parser first converts lwlC into CbIL where the compiler then compiles the list of\ninstructions into valid commad sequences. This article aims to document and detail the entire proccess of transforming the code.\n\n\nThe Preprocessor\n\n\nBefore any parsing of the code can happen, a preprocessor must come along to compile a list of valid symbols within the project. It will load any dependencies and compile a\nsymbols list for each of those. Once finished, it must also identify the main entry point of the code within the \"default\" project. Only once an entry point has been found,\ncan the parser come along to do its job. The entry point method must be static, and be inside a static class.\n\n\nThe Parser\n\n\nStarting at the top of the entry point method, the parser makes its way to the bottom of the method. It will track down all the objects used, and their respective symbols, parse\nthem, and add it to the final bytecode. The parser keeps a list of variables that it has initiated for GC (garbage collection) purposes. Everytime it has to enter a referenced\nmethod (i.e., constructor etc.) or a code block (i.e., if statements), the \ncode depth\n will be kept. If a variable's code depth exceeds that of the current code depth, that variable\nis considered to be \ngarbage\n and will be cleaned up to free up space. The garbage collection is done during the bytecode \u2192 command stage of the proccess.\n\nFor a more in-depth view on how the compiler treats each code statement, please refer to the \"Language\" portion of the documentation.\n\n\nOptimizations\n\n\nDue to the woefully unpotimized code that the parser may generate, the code needs to be cleaned up. Some optimizations take place during the parsing stage, and others, during the\ncompilation stage. Here is a quick overview of what is provoided:  \n\n\n\n\n \nUnrolling Loops:\n All loops will be unrolled while parsing the code.\n\n\n \nGarbage Collection:\n Garbage will be dealt with during the compilation.\n\n\n \nDead Code Elimination:\n Dead code elimination is dealt with during parsing\n\n\n \nUnused variables\n are removed during the parsing stage\n\n\n \nUnreachable code\n is removed during the parsing stage\n\n\n\n\n\n\n \nData flow analysis:\n Some data may be collapsed: \n{ b = 1; a = b + 2; }\n \u2192 \n{ a = 3; }",
            "title": "Specifications of the Compiler"
        },
        {
            "location": "/compiler/#the-parser-compiler-and-stuff",
            "text": "These are the two key components to the whole process of lwlC \u2192 CbIL \u2192 Command Blocks. The parser first converts lwlC into CbIL where the compiler then compiles the list of\ninstructions into valid commad sequences. This article aims to document and detail the entire proccess of transforming the code.",
            "title": "The Parser, Compiler and Stuff"
        },
        {
            "location": "/compiler/#the-preprocessor",
            "text": "Before any parsing of the code can happen, a preprocessor must come along to compile a list of valid symbols within the project. It will load any dependencies and compile a\nsymbols list for each of those. Once finished, it must also identify the main entry point of the code within the \"default\" project. Only once an entry point has been found,\ncan the parser come along to do its job. The entry point method must be static, and be inside a static class.",
            "title": "The Preprocessor"
        },
        {
            "location": "/compiler/#the-parser",
            "text": "Starting at the top of the entry point method, the parser makes its way to the bottom of the method. It will track down all the objects used, and their respective symbols, parse\nthem, and add it to the final bytecode. The parser keeps a list of variables that it has initiated for GC (garbage collection) purposes. Everytime it has to enter a referenced\nmethod (i.e., constructor etc.) or a code block (i.e., if statements), the  code depth  will be kept. If a variable's code depth exceeds that of the current code depth, that variable\nis considered to be  garbage  and will be cleaned up to free up space. The garbage collection is done during the bytecode \u2192 command stage of the proccess. \nFor a more in-depth view on how the compiler treats each code statement, please refer to the \"Language\" portion of the documentation.",
            "title": "The Parser"
        },
        {
            "location": "/compiler/#optimizations",
            "text": "Due to the woefully unpotimized code that the parser may generate, the code needs to be cleaned up. Some optimizations take place during the parsing stage, and others, during the\ncompilation stage. Here is a quick overview of what is provoided:       Unrolling Loops:  All loops will be unrolled while parsing the code.    Garbage Collection:  Garbage will be dealt with during the compilation.    Dead Code Elimination:  Dead code elimination is dealt with during parsing    Unused variables  are removed during the parsing stage    Unreachable code  is removed during the parsing stage      Data flow analysis:  Some data may be collapsed:  { b = 1; a = b + 2; }  \u2192  { a = 3; }",
            "title": "Optimizations"
        },
        {
            "location": "/language-docs/intro/",
            "text": "The Language of lwlC\n\n\n\n\nWarning\n\n\nAs the project is work-in-progress, many of the things documented may, and will change over time. I will try my best to update this as the project gets updated. Some features\ndocumented here may not exist in the project, and vice versa.\n\n\n\n\nUnlike its fully-fledged counterpart, C#, Lightweight C(#) is... well... lightweight. This means that it lacks many of the great features that makes C# great, but many of those\nfeatures are overkill compared to what this project hopes to accomplish.\n\nThe documentation of this language aims to document all the aspects of the lwlC syntax. \nIt will not, I repeat, will not document the libraries' methods\n. In other words, those\nMinecraft specific methods (\n/say\n, \n/kill\n etc.) \nwill not be documented\n. Those come in a library - a collection of code that someone else created. This portion of the\ndocumentation will only cover the basic syntax and concepts needed to do... well \nanything\n with the language.",
            "title": "Introduction"
        },
        {
            "location": "/language-docs/intro/#the-language-of-lwlc",
            "text": "Warning  As the project is work-in-progress, many of the things documented may, and will change over time. I will try my best to update this as the project gets updated. Some features\ndocumented here may not exist in the project, and vice versa.   Unlike its fully-fledged counterpart, C#, Lightweight C(#) is... well... lightweight. This means that it lacks many of the great features that makes C# great, but many of those\nfeatures are overkill compared to what this project hopes to accomplish. \nThe documentation of this language aims to document all the aspects of the lwlC syntax.  It will not, I repeat, will not document the libraries' methods . In other words, those\nMinecraft specific methods ( /say ,  /kill  etc.)  will not be documented . Those come in a library - a collection of code that someone else created. This portion of the\ndocumentation will only cover the basic syntax and concepts needed to do... well  anything  with the language.",
            "title": "The Language of lwlC"
        },
        {
            "location": "/language-docs/basics/",
            "text": "The Basics\n\n\nAs previously stated, an entry point \nmust\n exist in the \ndefault project\n. There must be 1, and only 1 entry point. The entry point must be \nstatic\n, and as a good programmer,\nshould be in a class called \nMain\n or \nProgram\n. The entry point must also have the name \nmain\n. Here is an example:\n\n\nnamespace\n \nTest\n\n\n{\n\n    \n// Doesn't need to be public\n\n    \npublic\n \nstatic\n \nclass\n \nMain\n\n    \n{\n\n        \n// Must be private. Can not be public.\n\n        \nstatic\n \nvoid\n \nmain\n()\n\n        \n{\n\n            \n// Main code goes here.\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nKeywords of lwlC\n\n\n\n\nTip\n\n\nClick on a keyword to learn more about it\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbase\n\n\npublic\n\n\nprivate\n\n\nget\n\n\nset\n\n\ndefault\n\n\n\n\n\n\nclass\n\n\nbool\n\n\nstring\n\n\nswitch\n\n\ncase\n\n\ndo\n\n\n\n\n\n\nchar\n\n\nint\n\n\nfloat\n\n\nenum\n\n\nusing\n\n\nvoid\n\n\n\n\n\n\ntrue\n\n\nfalse\n\n\nis\n\n\ntypeof\n\n\nconst\n\n\nget\n\n\n\n\n\n\nas\n\n\nif\n\n\nelse\n\n\nset\n\n\nstatic\n\n\nbreak\n\n\n\n\n\n\nwhile\n\n\nfor\n\n\nreturn\n\n\nnamespace\n\n\nthis\n\n\nnull\n\n\n\n\n\n\nref\n\n\nout\n\n\nnew\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nOh god.",
            "title": "Basics"
        },
        {
            "location": "/language-docs/basics/#the-basics",
            "text": "As previously stated, an entry point  must  exist in the  default project . There must be 1, and only 1 entry point. The entry point must be  static , and as a good programmer,\nshould be in a class called  Main  or  Program . The entry point must also have the name  main . Here is an example:  namespace   Test  { \n     // Doesn't need to be public \n     public   static   class   Main \n     { \n         // Must be private. Can not be public. \n         static   void   main () \n         { \n             // Main code goes here. \n         } \n     }  }",
            "title": "The Basics"
        },
        {
            "location": "/language-docs/basics/#keywords-of-lwlc",
            "text": "Tip  Click on a keyword to learn more about it                base  public  private  get  set  default    class  bool  string  switch  case  do    char  int  float  enum  using  void    true  false  is  typeof  const  get    as  if  else  set  static  break    while  for  return  namespace  this  null    ref  out  new",
            "title": "Keywords of lwlC"
        },
        {
            "location": "/language-docs/basics/#syntax",
            "text": "Oh god.",
            "title": "Syntax"
        },
        {
            "location": "/language-docs/base/",
            "text": "base (keyword)\n\n\nThe \nbase\n keyword allows access members of a base class from the inherited/derived class. Use it when:\n\n\n\n\nCalling an overriden method  \n\n\nSpecifying which base constructor should be called  \n\n\n\n\n\n\nNote\n\n\nLet's suppose this declaration: \nclass\n \nClassB\n : \nClassA\n. The base members called from ClassB will be those of ClassA, \nregardless of the base class of ClassA\n.\n\n\n\n\nExample\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\npublic\n \nclass\n \nClassA\n\n\n{\n\n    \npublic\n \nClassA\n(\nint\n \na\n)\n\n    \n{\n\n        \nmc\n.\nWriteLine\n(\n\"Base constructor called: \"\n \n+\n \na\n);\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nDoStuff\n()\n\n    \n{\n\n        \nmc\n.\nWriteLine\n(\n\"In base class!\"\n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nClassB\n \n:\n \nClassA\n\n\n{\n\n    \npublic\n \nClassB\n(\nint\n \na\n)\n \n:\n \nbase\n(\n123\n)\n \n//Call the constructor for ClassA\n\n    \n{\n\n        \nmc\n.\nWriteLine\n(\n\"Derived constructor called: \"\n \n+\n \na\n);\n\n    \n}\n\n\n    \npublic\n \noverride\n \nvoid\n \nDoStuff\n()\n\n    \n{\n\n        \nbase\n.\nDoStuff\n();\n \n//Call the DoStuff() in ClassA\n\n        \nmc\n.\nWriteLine\n(\n\"In derived class!\"\n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nstatic\n \nclass\n \nMain\n\n\n{\n\n    \nstatic\n \nvoid\n \nmain\n()\n\n    \n{\n\n        \nClassA\n \nbaseClass\n \n=\n \nnew\n \nClassA\n(\n42\n);\n\n        \nClassB\n \nderivedClass\n \n=\n \nnew\n \nClassB\n(\n456\n);\n\n\n        \nderivedClass\n.\nDoStuff\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe above program will output:\n\n\n1\n2\n3\n4\n5\nBase constructor called: 42\nBase constructor called: 123\nDerived constructor called: 456\nIn base class!\nIn derived class!",
            "title": "base"
        },
        {
            "location": "/language-docs/base/#base-keyword",
            "text": "The  base  keyword allows access members of a base class from the inherited/derived class. Use it when:   Calling an overriden method    Specifying which base constructor should be called      Note  Let's suppose this declaration:  class   ClassB  :  ClassA . The base members called from ClassB will be those of ClassA,  regardless of the base class of ClassA .",
            "title": "base (keyword)"
        },
        {
            "location": "/language-docs/base/#example",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37 public   class   ClassA  { \n     public   ClassA ( int   a ) \n     { \n         mc . WriteLine ( \"Base constructor called: \"   +   a ); \n     } \n\n     public   void   DoStuff () \n     { \n         mc . WriteLine ( \"In base class!\" ); \n     }  }  public   class   ClassB   :   ClassA  { \n     public   ClassB ( int   a )   :   base ( 123 )   //Call the constructor for ClassA \n     { \n         mc . WriteLine ( \"Derived constructor called: \"   +   a ); \n     } \n\n     public   override   void   DoStuff () \n     { \n         base . DoStuff ();   //Call the DoStuff() in ClassA \n         mc . WriteLine ( \"In derived class!\" ); \n     }  }  public   static   class   Main  { \n     static   void   main () \n     { \n         ClassA   baseClass   =   new   ClassA ( 42 ); \n         ClassB   derivedClass   =   new   ClassB ( 456 ); \n\n         derivedClass . DoStuff (); \n     }  }    The above program will output:  1\n2\n3\n4\n5 Base constructor called: 42\nBase constructor called: 123\nDerived constructor called: 456\nIn base class!\nIn derived class!",
            "title": "Example"
        },
        {
            "location": "/issue/",
            "text": "Issues, Bugs and the Likes\n\n\nIssues with Documentation\n\n\nDocumentation issues/inaccuracies can be reported through the comments or directly to me via email, however, the \nformer is recommended\n. \nYou may also suggest fixes throug the \ngh-pages\n branch of the GitHub issue tracker.\nThe comment section can be used to suggest fixes or additions. If comments are down, you may contact me at:\n\n\nkevindai02@gmail.com\n  \n\n\n\n\nWarning\n\n\nSpam of any kind is \nnot welcome\n, and will be reported and deleted.\n\n\n\n\nIssues/Bugs with Code\n\n\nAll issues are to be reported to the GitHub issue tracker. Please \ndo not\n report in the comments. Emailing me about it is \nnot recommended\n as I will \nnot\n be happy about it.\nIf you would like to contribute to the repository, create a pull request to merge your contribution to mine. Contributions are greatly \nwelcomed\n.",
            "title": "Issue Tracking"
        },
        {
            "location": "/issue/#issues-bugs-and-the-likes",
            "text": "",
            "title": "Issues, Bugs and the Likes"
        },
        {
            "location": "/issue/#issues-with-documentation",
            "text": "Documentation issues/inaccuracies can be reported through the comments or directly to me via email, however, the  former is recommended . \nYou may also suggest fixes throug the  gh-pages  branch of the GitHub issue tracker.\nThe comment section can be used to suggest fixes or additions. If comments are down, you may contact me at:  kevindai02@gmail.com      Warning  Spam of any kind is  not welcome , and will be reported and deleted.",
            "title": "Issues with Documentation"
        },
        {
            "location": "/issue/#issuesbugs-with-code",
            "text": "All issues are to be reported to the GitHub issue tracker. Please  do not  report in the comments. Emailing me about it is  not recommended  as I will  not  be happy about it.\nIf you would like to contribute to the repository, create a pull request to merge your contribution to mine. Contributions are greatly  welcomed .",
            "title": "Issues/Bugs with Code"
        }
    ]
}