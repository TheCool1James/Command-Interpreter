Each element of the stack can only be up to 64 bits (long)! Note how there is stack: in brackets below. This will be the portion of the stack modified.

0x00: Null string terminator (MNEMONIC: n/a)

0x01: Push an object into stack (stack: object id -> stack: object value) (MNEMONIC: push)**
0x02: Push an integer into stack (stack: variable id -> stack: variable value) (MNEMONIC: ipush)**

0x03: Swap the top 2 values on the stack (stack: a, b -> stack b, a) (MNEMONIC: swap)
0x04: Call library method (stack: arg n, arg n-1.. arg0, method ID -> stack: return value) (MNEMONIC: call)

0x05: RESERVED, see opcode 0x2A (MNEMONIC: db)

0x06: Return void after call (MNEMONIC: ret)
0x07: Return value after call (stack: return value) (MNEMONIC: iret)

0x08: BREAKPOINT (MNEMONIC: magic)
0x09: EXCEPTION (stack: all cleared), activates command block to write exception (MNEMONIC: error)
0x0A - 0x19: RESERVED FOR LIBRARY AND REFERENCES USE ONLY (MNEMONIC: n/a)

0x2A: Insert raw Minecraft command (stack: arg n, arg n-1 ... arg0, null terminated string in 64-bit chunks) (MNEMONIC: _raw)
    - Note that the string stored in the stack must be null terminated with 0x0000 (yes, that's 4 bytes)
    - Note if there is 0x05 following the the null termination, then it signals a reference to an argument. The 0x05 is then followed by the argument id
    - The argument is structured like an object

0x2B: Registers a new empty variable (stack: variable type id, variable name hashed -> stack:)(MNEMONIC: irv)
0x2C: Registers a new object (stack: object type id, object name hashed -> stack:)(MNEMONIC: ro)

0x2D: Pop integer from stack into variable (stack: variable id, value -> stack:)(MNEMONIC: ipop)**
0x2E: Pops object from stack into another object (stack: target object id, source object id -> stack:)(MNEMONIC: pop)**

0x2F: Push a string into string register* (register : variable id -> register : variable value) (MNEMONIC: spush) **
0x30: Push a long into stack (stack: variable id -> stack: variable value) (MNEMONIC: lpush)**
0x31: Push a boolean into stack (stack: variable id -> stack: variable value) (MNEMONIC: bpush)**

0x32: Pops string from register* into variable (register: variable id, value -> register:)(MNEMONIC: spop) **
0x33: Pops long from stack into variable (stack: variable id, value -> stack:)(MNEMONIC: lpop)**
0x34: Pops boolean from stack into variable (stack: variable id, value -> stack:)(MNEMONIC: bpop)**

0x35: Loads string  into register (MNEMONIC: lods)
0x36: Loads long    into register (MNEMONIC: lodl)
0x37: Loads boolean into register (MNEMONIC: lodb)
0x38: Loads integer into register (MNEMONIC: lodi)

0x39: Loads register into stack (MNEMONIC: pops)
0x3A: Loads register into stack (MNEMONIC: popl)
0x3B: Loads register into stack (MNEMONIC: popb)
0x3C: Loads register into stack (MNEMONIC: popi)


How it all operates:
Roslyn Parser ->[References]-> OPCODES ->[Library]-> Command Blocks

A [Reference] contains all the variable structures. It contains all the system-required method names hashed, ther corresponding IDs
and their structures. This will be written in CBIL, and compiled to the same bytecode above.
A [Library] contains all the code linked to the system-required methods. The names of each method should match that of the [Reference]. This will be
written in CBIL, and compiled to the bytecode above.
A [structure] is something to define the structure a variable/object that will be stored in the stack. Think of classes.

A variable will be stored in a variable dictionary with the id and it's corresponding type and hashed name.
An object will be stored in an object dictionary with the id and it's corresponding type and hashed name.

0x0A: A 2-byte variable structure ID follows. This will be the ID that will identify the variable type. (MNEMONIC: var)
0x0B: A SHA1 object structure ID follows. This will be the ID that will identify the object type. (MNEMONIC: obj)
0x0C: A 0x0000 goes in front of it to define the end of the structure (MNEMONIC: n/a)
0x0D: Defines the start of a method, it then is followed by a hashed string, the object id, and the flags (stack: array of N variable structures as it's arguments) (MNEMONIC: [name] [id] [flags]:)
0x0E: Defines the start of a class, it is then followed by a hashed string (the id of the object). (MNEMONIC: class [name]:)
0x0F: Namespace name (MNEMONIC: namespace [name]:

All methods + variables in a class would be names [namespace].[class].[name] to give each class an unique id name

Example CBIL script:

using CBIL;
namespace ExampleScript
{
    class Example
    {
        string exampleString = "Hello World";
        void main()
        {
            printLn(exampleString);
        }
    }
}

Bytecode Mnemonics:

namespace ExampleScript:
class ExampleScript.Example:
    irv 0x5 ExampleScript.Example.exampleString
    lods "Hello World"
    spop ExampleScript.Example.exampleString
    ExampleScript.Example.Main void private:
        spush ExampleScript.Example.exampleString
        call CBIL.Print.printLN

namespace CBIL:
class CBIL.Print:
    CBIL.Print.printLN void public static:
        irv 0x5 CBIL.Print.printLN.s
        spop CBIL.Print.printLN.s
        _raw "say @a" db CBIL.Print.printLN.s
        ret